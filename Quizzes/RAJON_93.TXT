     1. Расстояния между городами
     N городов  расположены  вдоль  одной  дороги.  Необходимо
разработать справочную систему,  которая для любых двух задан-
ных городов сообщает расстояние между ними. Предложите органи-
зацию данных и алгоритм,  который делает это с минимальной не-
обходимой памятью и за как можно меньшее количество операций.

     2. Поиск отсутствующего числа
     а). В таблице из N элементов хранятся целые числа от 0 до
N. Одинаковых чисел в таблице нет.  Напишите алгоритм, опреде-
ляющий целое число от 0 до N, которого нет в таблице.
     б). В таблице из N элементов хранятся целые числа от 0 до
N. Напишите алгоритм,  определяющий все целые числа от 0 до N,
которых нет в таблице.
     в). В таблице из N элементов хранятся целые числа от 0 до
K,  K > N.  Напишите алгоритм, определяющий какое-нибудь целое
число от 0 до K, которого нет в таблице при условии, что алго-
ритм  не  должен использовать других таблиц,  кроме заданной и
изменять значения заданной таблицы.

     3. Число сочетаний
     Известно, что если есть N предметов и надо выбрать из них
K предметов,  то есть N!/(K!*(N-K)!) вариантов выбора,  где X!
означает произведение всех целых чисел от  1  до  X.  Напишите
программу, которая для заданных N и K вычисляет количество ва-
риантов выбора K предметов из N,  выполняя  как  можно  меньше
арифметических операций.

     4. Числовой фокус
     а). Напишите программу,  реализующую такой фокус: человек
задумывает целое число от 0 до 1000,  вычисляет остатки от де-
ления  этого числа на 7,  11 и 13 и сообщает эти остатки прог-
рамме. Программа должна определить задуманное число.
     б). Напишите программу, реализующую такой фокус: заданы N
взаимно простых чисел K[1], K[2],..., K[N]; человек задумывает
целое число  от 0 до K[1]*K[2]*...*K[N],  вычисляет остатки от
деления этого числа на K[1],  K[2],...,  K[N] и  сообщает  эти
остатки  программе.  Программа  должна  определить  задуманное
число.

     РЕШЕНИЯ ЗАДАЧ
     1. Расстояния между городами
     Две очевидные идеи не очень  эффективны.  Если  составить
таблицу N*N, содержащую расстояния между всеми парами городов,
то алгоритм поиска  расстояния  будет  прост,  но  потребуется
слишком много  памяти.  Если в таблице из N-1 элемента хранить
расстояния между соседними городами, то памяти потребуется го-
раздо меньше,  но  для вычисления расстояния придется суммиро-
вать элементы таблицы в цикле,  на что может потредоваться  до
N-2 операций сложения.
     Третий способ требует N элементов памяти для хранения ин-
формации  и одну арифметическую операцию для вычисления любого
расстояния.  Для этого надо в таблице из N  элементов  хранить
расстояния  от каждого из городов до одного из крайних.  Тогда
расстояние между любыми двумя городами будет равно  абсолютной
величине  разности расстояний от этих городов до крайнего,  то
есть абсолютной  величине  разности  соответствующих  значений
элементов таблицы.
     Описание алгоритма очевидно.

     2. Поиск отсутствующего числа
     а). Лучший алгоритм использует то условие,  что каждое из
N+1 чисел  встречается в таблице не более,  чем один раз (N из
них встречается 1 раз,  а только одно не  встречается  вообще,
его и надо найти). Все числа от 0 до N образуют арифметическую
прогрессию с  суммой  N*(N-1)/2.  Единственное   отсутствующее
число можно найти, вычтя из этой суммы все присутствующие.

     АЛГ ЦЕЛ число_которого_нет (ЦЕЛ N, ЦЕЛ ТАБ A[1:N])
     HАЧ ЦЕЛ i
      ЗНАЧ := N*(N-1)/2
      ДЛЯ i ОТ 1 ДО N
      НЦ
       ЗНАЧ := ЗНАЧ - A[i]
      КЦ
     КОН

     б). Есть два хороших способа решения.
     Первый алгоритм сначала упорядочивает исходную таблицу A,
а  затем последовательно просматривает ее,  сравнивая соседние
значения. Если они отличаются не более чем на 1, то между ними
нет отсутствующих  чисел.  Если  разность  между A[i-1] и A[i]
больше 1,  то все числа от A[i-1]+1 до A[i]-1 в таблице не со-
держатся. Кроме того,  если A[1] > 0,  то чисел от 0 до A[1]-1
нет в таблице,  и если A[N] < N, то чисел от A[N]+1 до N нет в
таблице.

     АЛГ числа_которых_нет1 (ЦЕЛ N, ЦЕЛ ТАБ A[1:N])
     HАЧ ЦЕЛ i, j
      упорядочение (N, A)
      ДЛЯ j ОТ 0 ДО A[1]-1
      НЦ
       ВЫВОД(j)
      КЦ
      ДЛЯ i ОТ 2 ДО N
      НЦ
       ЕСЛИ A[i]-A[i-1] > 1
       TO ДЛЯ j ОТ A[i-1]+1 ДО A[i]-1
          НЦ
            ВЫВОД(j)
          КЦ
       ВСЕ
      КЦ
      ДЛЯ j ОТ A[N]+1 ДО N
      НЦ
       ВЫВОД(j)
      КЦ
     КОН

     Другой алгоритм использует счетчики, определяющие, сколь-
ко раз каждое число от 0 до N входит в исходную  таблицу.  Эти
счетчики сами расположены во вспомогательной таблице,  индексы
которой - числа от 0 до N - определяются из значений элементов
исходной таблицы. Когда для всех чисел от 0 до N будут опреде-
лены количества их вхождений в исходную таблицу, вспомогатель-
ная таблица  просматривается  и определяются все числа с коли-
чествами вхождений, равными 0.

     АЛГ числа_которых_нет2 (ЦЕЛ N, ЦЕЛ ТАБ A[1:N])
     HАЧ ЦЕЛ i, k, ЦЕЛ ТАБ Счетчик[0:N]
      ДЛЯ i ОТ 0 ДО N
      НЦ
       Счетчик[i]:=0
      КЦ
      ДЛЯ i ОТ 1 ДО N
      НЦ
       Счетчик[A[i]] := Счетчик[A[i]] + 1
      КЦ
      ДЛЯ i ОТ 0 ДО N
      НЦ
       ЕСЛИ Счетчик[i] = 0
       ТО ВЫВОД(i)
       ВСЕ
      КЦ
     КОН

     в). Можно в двух вложенных циклах сравнить каждый элемент
исходной таблицы  с каждым числом от 1 до К.  Более эффективно
деление пополам отрезка возможных значений чисел. Вначале этот
отрезок равен [0,  K].  Так как K+1 > N,  на этом отрезке есть
числа, отсутствующие в исходной таблице.  На каждом шаге теку-
щий отрезок  делится пополам, после чего исходная таблица про-
сматривается и для каждой из половин текущего отрезка  подсчи-
тывается количество чисел исходной таблицы, принадлежащих этим
половинам. В качестве текущего отрезка выбирается та половина,
в которую попало меньше чисел из исходной таблице,  чем в дру-
гую. Это гарантирует наличие в  новом  текущем  отрезке  таких
чисел, которых  нет  в исходной таблице.  Поиск заканчивается,
когда в текущем отрезке окажется 0 чисел.

     АЛГ ЦЕЛ число_которого_нет (ЦЕЛ N, K, ЦЕЛ ТАБ A[1:N])
     HАЧ ЦЕЛ L, R, M, "левый край, правый край и середина
                       текущего отрезка"
             SL, SR, S, "суммы в левой и правой половинах
                         и на всем отрезке"
             i "индекс"
       S := N
       L := 0
       R := K
       ПОКА S > 0
       НЦ
         M := (L+R)/2 "предполагается целочисленное деление,
                       округление с недостатком"
         SL := 0
         SR := 0
         ДЛЯ i ОТ 1 ДО N
         НЦ
           ЕСЛИ (A[i] >= L) И (A[i] <= M)
           ТО SL := SL+1
           ИНАЧЕ ЕСЛИ (A[i] > М) И (A[i] <= R)
           ТО SR := SR+1
           ВСЕ
           ВСЕ
           ЕСЛИ SL < SR
           ТО
             S := SL
             R := M
           ИНАЧЕ
             S := SR
             L := M+1
           ВСЕ
         КЦ
       КЦ
       ЗНАЧ := L
     КОН

     3. Число сочетаний
     Вычисление по формуле в лоб с трехкратным вызовом вспомо-
гательного алгоритма  факториала  во-первых  требует   слишком
большого количества умножений, а во-вторых неработоспособно во
многих случаях  при  практической  реализации  из-за  быстрого
роста факториала, в то время как само значение числа сочетаний
относительно невелико (например, рекомендуется проверить алго-
ритм для определения числа сочетаний из 1993 по 1992). Выход -
сокращение в числителе и знаменателе K!  или (N-K)!  в зависи-
мости от того, какое из этих чисел больше. Далее число сочета-
ний определяется в одном цикле, на каждом шаге которого проме-
жуточное  значение  домножается  на один множитель числителя и
делится на один множитель знаменателя.  Обратите внимание, что
промежуточный результат  может  оказаться  дробным числом!  На
практике при этом могут накопиться ошибки округления, и в кон-
це результат должен быть округлен до целого.

     АЛГ ЦЕЛ С(ЦЕЛ N, K)
     АРГ N, K
     HАЧ ЦЕЛ i,m, ВЕЩ r
       ЕСЛИ 2*K > N
       ТО m := N-K
       ИНАЧЕ m := K
       ВСЕ
       r := 1
       ДЛЯ i ОТ 1 ДО m
       НЦ
         r := r*(N-i+1)/i
       КЦ
       ЗНАЧ := r
     КОН

     4. Числовой фокус
     а). Хотя  у  задачи  есть  алгебраическое решение,  можно
предложить простой алгоритм, который перебирает все числа от 0
до 1000, дающие требуемый остаток от деления на 13, и проверя-
ет остатки от их деления на 7 и 11.

     АЛГ ЦЕЛ фокус1 (ЦЕЛ r7, r11, r13)
     АРГ r7, r11, r13
     HАЧ
       ЗHАЧ := r13
       ПОКА (ЗНАЧ <= 1000)
          И (остаток(ЗНАЧ, 7) <> r7)
          И (остаток(ЗНАЧ, 11) <> r11)
       НЦ
         ЗHАЧ := ЗНАЧ + 13
       КЦ
       ЕСЛИ ЗНАЧ > 1000
       ТО ВЫВОД('Ошибка !!!')
       ВСЕ
     КОH

     Другая идея:  в цикле пробавлять к переменным r7, r11 или
r13 соответственно 7,  11 или 13 до тех пор,  пока их значения
не сравняются  (полученное  значение равно искомому числу) или
одно из значений не превзойдет 1000.  Hа  каждом  из  проходов
цикла соответствующее число прибавляется к переменной, имеющей
минимальное значение среди r7, r11 и r13.

     АЛГ ЦЕЛ фокус2 (ЦЕЛ r7, r11, r13)
     АРГ r7, r11, r13
     HАЧ
       ПОКА (r7 <= 1000)
          И (r11 <= 1000)
          И (r13 <= 1000)
          И (r7 <> r11)
          И (r7 <> r13)
       НЦ
         ЕСЛИ (r7 < r11) И (r7 < r13)
         ТО    r7 := r7 + 7
         ИНАЧЕ ЕСЛИ (r11 < r13)
         ТО    r11 := r11 + 13
         ИHАЧЕ r13 := r13 + 13
         ВСЕ
         ВСЕ
       КЦ
       ЕСЛИ (r7 > 1000)
        ИЛИ (r11 > 1000)
        ИЛИ (r13 > 1000)
       ТО ВЫВОД('Ошибка !!!')
       ИНАЧЕ ЗНАЧ := r7
       ВСЕ
     КОH

     б). Обобщение  любой  из идей для подзадачи а) даст алго-
ритм подзадачи б). Таблицу остатков придется перебирать в цик-
ле. При реализации первой идеи целесообразно организовать цикл
для максимального среди делителей. Выход из цикла организуется
по значению флага. Приведем реализацию первой идеи.

     АЛГ ЦЕЛ фокус (ЦЕЛ N, ЦЕЛ ТАБ r, k [1:N])
     АРГ N, r, k
     HАЧ ЦЕЛ pk, kmax, i, imax
         ЛИТ флаг
     "вычисление произведения остатков и максимального остатка"
       pk := k[1]
       imax := 1
       kmax := k[1]
       ДЛЯ i ОТ 2 ДО N
       НЦ
         pk := pk*k[i]
         ЕСЛИ k[i] > kmax
         ТО
           imax := i
           kmax := k[i]
         ВСЕ
       КЦ
     "поиск числа"
       ЗHАЧ := r[imax] - kmax
       ПОКА флаг = 'не конец'
       НЦ
         ЗHАЧ := ЗНАЧ + kmax
         флаг := 'конец'
         ЕСЛИ ЗНАЧ <= pk ТО
         ДЛЯ i ОТ 1 ДО N
         НЦ
           ЕСЛИ остаток(ЗНАЧ, k[i]) <> r[i])
           ТО флаг := 'не конец'
           ВСЕ
         КЦ
       КЦ
       ЕСЛИ ЗНАЧ > pk
       ТО ВЫВОД('Ошибка !!!')
       ВСЕ
     КОH

     Кстати, любой   набор  остатков  от  деления  на  взаимно
простые числа k[1],  k[2],...,  k[N] взаимно однозначно  соот-
ветствует некоторому числу от 1 до k[1]*k[2]*...*k[N].
