                            ЗАДАЧИ
          ЗАОЧНОГО ТУРА ОЛИМПИАДЫ ПО ИНФОРМАТИКЕ

ЗАДАЧА 1. "Я - свой".   (до 20 баллов)

Система ПВО автоматически опознает "свои" самолеты и самолеты-
нарушители. Для этого применяется следующий прием. Обнаружив в
своем  воздушном  пространстве  неизвестный  летающий  объект,
Система  посылает  ему  сигнал-запрос.  Если  объект  в  ответ
присылает   правильный   сигнал-отзыв,   Система  считает  его
"своим".  Если  объект присылает неправильный отзыв или вообще
не   отвечает,  Система  считает  его  нарушителем,  со  всеми
вытекающими последствиями.

Для  того,  чтобы злоумышленник, наблюдающий все сеансы обмена
сигналами,   не   смог  выдать  себя  за  своего,  Система  не
использует  дважды  один  и  тот же запрос. Специализированный
компьютер,   который  находится  на  борту  "своего"  самолета
получает   запрос,   по   специальному   алгоритму   вычисляет
правильный  отзыв и посылает его системе. Такой же компьютер ,
работающий по такому же алгоритму, есть и у самой Системы, так
что она имеет возможность сравнить значения, вычисленные этими
двумя компьютерами. Совпали - значит "свой".

Считается, что алгоритм формирования отзыва абсолютно секретен
и  нам  неизвестен.  Однако  известны некоторые характеристики
бортового  компьютера.  Так,  например,  известно, что система
команд   этого   компьютера   содержит  только  такие  команды
обработки  данных:  ввод числа в ячейку памяти, вывод числа из
ячейки  памяти,  пересылка  числа  из  одной  ячейки  памяти в
другую, а также логические операции AND, OR, NOT, XOR, которые
выполняются   одновременно   над   всеми  двоичными  разрядами
чисел-операндов (как, например, в Турбо Паскале).

Задача   заключается   в   том,  чтобы  научиться  формировать
правильный отзыв, не зная секретного алгоритма.

Пусть запрос - это последовательность целых чисел a[i]: 0<=a[i]
<=M, i = 1, 2, ..., N, отзыв - это число b: 0<=b<=M, 0<=M<=
1000000000, 1<=N<=10, и бортовой компьютер может обрабатывать числа
такой  величины.  M и N во время работы Системы не изменяются,
но могут изменяться при ее перенастройке.

Составьте   программу  YA-SVOY,  которая  выполняет  следующие
действия.
1. Получает очередной запрос при помощи функции Query.
2.  Может  обращаться за помощью к функции Reply для получения
правильного отзыва на данный запрос.
3.  Не  обращается  к функции Reply, если может сама вычислить
правильный отзыв.
4.   Для   каждого  запроса  выводит  в  текстовый  ASCII-файл
YA-SVOY.SOL   соответствующий   отзыв  в  порядке  поступления
запросов (по одному числу в каждой строке).

Функции Query и Reply - внешние по отношению к Вашей программе
и  прилинковываются  в составе файла с именем QR.PAS так,  что 
Вы не должны знать, что у них на самом деле внутри.  На  время
отладки  программы  на языке Турбо Паскаль  можно представлять
себе эти функции следующим образом.

Unit QR;

Interface

  const
     N = 10;
     MaxNum = 1000000000;
  type
     TNum = 1..MaxNum;
     TQuery = array[1..N] of TNum;

  function  Query(Var q: TQuery): Boolean;
  function  Reply(Var q: TQuery): TNum;

Implementation

  var
    count: byte;

  function  Query(Var q: TQuery): Boolean;
  var
    i: Integer;
  begin
    Query:=FALSE;
    if count=0 then Exit;
    Dec(count);
    for i:=1 to N do
      q[i]:=TNum(Random($FFF)) shl 16 + Random($FFFF);
    Query:=TRUE;
  end;    { Query }

  function  Reply(Var q: TQuery): TNum;
  var
    i: Integer;   res: TNum;
  begin
    res:=q[1];
    for i:=2 to N do res:=res xor q[i];
    Reply:=res;
  end;    { Reply }
begin
  count := 8;
end.

Во  время  контрольной  проверки  вместо  этих  функций  будут
прилинкованы другие функции с тем же интерфейсом.
При  оценивании лучшей считается та программа, которая большее
число  правильных результатов получила самостоятельно, то есть
без помощи функции Reply.

Пример 1. Тривиальное решение на языке Турбо Паскаль.

Uses QR;

var
  q: TQuery;
  f: Text;
begin
  Assign(f,'YA-SVOY.SOL');
  ReWrite(f);
  while Query(q) do
    writeln(f,Reply(q));
  Close(f);
end.

ЗАДАЧА 2. "Алиса3".      (до 50 баллов)

Как  и  прежде,  Алиса  ведет  переписку  с  Бобом,  используя
преимущества  электронной почты. На этот раз открытым текстом.
Несмотря  на  то,  что теперь их разделяют границы государств,
юные друзья регулярно обмениваются мыслями о прочитанном.

Бдительный чиновник Государственной Криптоаналитической Службы
знает  с  кем  имеет  дело  и  поэтому  ищет  скрытый  смысл в
безобидных посланиях Алисы.

Кто  ищет,  тот  находит.  Проанализировав  электронные версии
посланий  Алисы и Боба, криптоаналитик нашел-таки в них тайный
смысл. Правда, злые языки утверждают, что таким способом можно
найти  тайный  смысл  в  чем  угодно, например, в прижизненных
изданиях произведений Шекспира, если за это платят деньги. Что
ж, криптоаналитиков не судят.

Впрочем,   судите   сами,  Вам  доступны  примеры  электронных
материалов, которыми пользовался криптоаналитик.

Составьте  программу  ALISA3,  которая тем, кто любит секреты,
помогает проникнуть в скрытый смысл посланий Алисы, а тем, кто
любит  засекречивать,  помогает скрыть тайный смысл в открытом
тексте.

Требования к программе.
1.   Программа  вводит  из  командной  строки  заданные  имена
исходных  и  результирующих  файлов. Все файлы - это текстовые
ASCII-файлы.
2.  Если  в командной строке задано три имени файла, программа
скрывает  содержимое  второго  файла  в тексте первого файла и
помещает результат в третий файл.
3.  Если  в командной строке задано два имени файла, программа
извлекает  скрытый  текст  из  первого файла и помещает его во
второй файл.
4.  В  том  случае,  если  скрыть  предложенный  текст нельзя,
программа выдает в результирующий файл текст "NO SOLUTION".
5.  Программа  делает  свою  работу  в точности так, как этого
требуют приведенные ниже примеры.


Пример 1. Письмо Алисы.
Открытый текст.
HELLО, БOБ.
HЫНЧE BEТPEHO И ВОЛHЫ С ПEРEХЛECТOМ. ПО-ПРEЖНЕМУ
КУПАTЬCЯ XOЛOДHО, ПOЭTОMУ МHOГO ЧИTАЮ. ПО-BИДИМOMУ,
ВСE ЗHАМЕHИTЫЕ ПИCAТEЛИ ДEЛЯTСЯ НА ДВE KАTЕГOPИИ:
ОДHИ СНAЧАЛА ПИШУT, A ПОTОМ ОТСEKAЮT BCЕ ЛИШНEE,
ДPУГИЕ HE ПИШУТ ЛИШНEГО. И ТЕ И ДPУГИЕ ПОЛЬЗУЮТСЯ
OДНИМ ИHСTPУMEHTOM: "ЕNTIA NON SUNТ МULTIPLICАNDА
РRAЕTER NЕСESSITАТEM". TЫ, KAК OБЪEKTНO-OPИЕНTИРOBAHНЫЙ
ПPОГРAМMИCT, KOHEЧHO ЗHAEШЬ EГO HAЗBAHИE.
CKУЧAЮ. AЛИCA.

Извлеченный тайный текст.
ГРАФИНЯ ИЗМЕНИВШИМСЯ ЛИЦОМ БЕЖИТ ПРУДУ

Пример 2. Письмо Боба.
Открытый текст.
ПPИBЕT, ALIСE.
ЗДECЬ У НАC ТOЖE XОЛOДHO, TОЖE CПЛОШНЫE ПEРЕXЛEСТЫ
И TOЖE CKOPO OCЕНЬ. HAПИШИ, ECЛИ ЧTO-ТО ИЗMEНИТCЯ
B ОКРУГE. ЧTО KAСAEТCЯ ИHСTРУМЕHТА, TО Я ИМ TOЖE
ПOЛЬЗУЮCЬ, OCOБЕHHО ПО УТРАМ. HA PAБОTЕ УМHOЖAЮ
CУЩНOСТИ ПO ПРOИЗВOДCТBEHHOЙ HEOБХOДИМOCTИ. КCTATИ,
ЕСЛИ TEБЯ ОДОЛЕЮТ СУЩHOСТИ, ПОЧИТАЙ ПИTEPA ЧEHА
( HЕ ПУТATЬ C ПИTЕРOM ПЭHОM И ДЖEKKИ ЧАHОМ ).
EГО MOДEЛЬ TОЖE ПОMOГAEТ, ХОТЯ И HE TАК РАДИKАЛЬНO.
ЦEЛУЮ. БOБ.
Извлеченный тайный текст.
ГРУЗИТЕ АПЕЛЬСИНЫ БОЧКАМИ БРАТЬЯ КАРАМАЗОВЫ

Пример 3. "Нельзя скрыть".
Открытый текст.
TO BE OR NOT TO BE?
Упрятываемый тайный текст.
TO BE!
Результат.
NO SOLUTION

ЗАДАЧА 3. "Кибернетические стихи".      (до 100 баллов)

По  определению,  киберстих  -  это  последовательность  целых
положительных  чисел,  разбитая  на  строки  в  соответствии с
заданным ритмом ( стихотворным размером).

Рифмующимися  назовем  строки, у которых последний слог каждой
строки звучит одинаково.

Стихотворный   размер  -  это  последовательность  чередования
ударных и безударных слогов.

В  стихотворении  первая  строка  может рифмоваться со второй,
третья  -  с  четвертой,  или первая - с третьей, а вторая - с
четвертой, или как-нибудь иначе; некоторые строки могут вообще
ни с чем не рифмоваться.

Максимум  киберстиха  -  наибольший член последовательности, -
ограничен сверху известной константой M.

В классическом киберстихе ни одно из чисел не повторяется дважды.

Задача  заключается  в  том, чтобы для заданного стихотворного
размера   и   заданного  порядка  рифмования  строк  составить
классический киберстих с наименьшим максимумом.

Понятно,  что  на  разных  языках  числа произносятся и звучат
по-разному. Поэтому при решении задачи следует учитывать язык.
Мы ограничимся языками украинским и русским.

Составьте программу CYBARD, которая:
a)  считывает  язык,  стихотворный размер и порядок рифмования
строк из текстового ASCII-файла CYBARD.DAT;
b) проверяет корректность исходных данных;
c) составляет искомое стихотворение;
d)    если    решение    существует,   записывает   полученное
стихотворение  в текстовый ASCII-файл CYBARD.SOL; если решение
не   существует,  записывает  в  файл  CYBARD.DAT  строку  "NO
SOLUTION";
e) при нажатии на клавишу ESC (escape) на клавиатуре программа
в  течение  1 секунды записывает наилучшее найденное на данный
момент решение и прекращает работу.

Исходные данные в файле CYBARD.DAT расположены так:

в  первой  строке  файла помещается текст из трех символов UKR
или RUS, определяющий выбор языка;

вторая строка содержит пару чисел N и M, разделенных пробелом;
число   M   -   это  максимально  возможное  значение  числа в
стихотворении   (M<1000),   число   N   -  количество  строк в
стихотворении (0<N<20);

(i+2)-я  строка  файла содержит стихотворный размер i-й строки
стихотворения   (i=1,2,...,N);  стихотворный  размер  задается
текстовой  строкой,  состоящей  из  не  более чем 255 символов
'-'(минус)  и  '/'(дробная черта); для обозначения безударного
слога  используют символ '-', для обозначения ударного слога -
символ '/';

каждая  из оставшихся K строк файла содержит пару чисел I и J,
разделенных  пробелом,  - это номера рифмующихся строк (0<=K<=N,
0<I,J<=N).

Результирующие данные в файле CYBARD.SOL должны располагаться
следующим образом:
  первая строка файла содержит текст UKR или RUS;
  вторая строка файла содержит число N;
  третья строка файла содержит  число равное наименьшему
максимуму стихотворения;
  (i+3)-я строка файла содержит i-ю  строку  составленного
стихотворения  - последовательность целых положительных чисел,
разделенных пробелами (i=1,2,...,N).

Ограничения.
1.  Простые  и сложные числительные имеют только одно - притом
постоянное, - ударение.
2.  Составное числительное имеет несколько ударений, каждое из
которых  принадлежит  одной  составной  части  -  простому или
сложному    числительному.    Все    эти   ударения   являются
обязательными,  ни  одно  из них не может исчезать.. Например,
числу 494 соответствует такой размер: -/----/--/-.
3.  Для  каждого числительного рассматривается только основной
общепринятый  вариант  произношения.  Например,  "один",  а не
"раз",  "два",  а  не  "двойка"  или  "оба", "пятьдесят", а не
"полста".
4.  Нельзя  переносить  слова  с  одной  строки на другую. При
оценивании  решения  лучшей считается та программа, которая за
отведенное ей время находит киберстих с наименьшим максимумом.

Пример 1. "Стансы".
Файл CYBARD.DAT
UKR
4 440
--/--/---/--/
--/--/---/--/
--/--/---/--/
--/--/---/--/
1 2
3 4

Файл CYBARD.SOL
UKR
4
401
14 12 91
11 400 4 1
19 401 70
18 13 60 50

Пример 2. "Стансы".
Файл CYBARD.DAT
RUS
4 999
--/--/---/--/
--/--/---/--/
--/--/---/--/
--/--/---/--/
1 2
3 4

Файл CYBARD.SOL
RUS
4
404
94 91
90 404 1
19 400 402
18 14 11 2

Пример 3. "NO SOLUTION".
Файл CYBARD.DAT
UKR
1 999
-/---

Файл CYBARD.SOL
NO SOLUTION


ТРЕБОВАНИЯ К ОФОРМЛЕНИЮ РЕЗУЛЬТАТОВ

1. Программу-решение следует поместить в текстовый ASCII-файл,
который имеет имя, указанное в условии задачи, и расширение .PAS.

Исходный  текст  программы-решения  должен  содержать описание
режимов  трансляции  на  тот случай, если жюри будет вынуждено
перетранслировать представленный исходный текст. Например, для
включения  опций  компиляции  в  текст программы в среде Турбо
Паскаля  достаточно  выполнить  команду  CTRL-O+O.

2. Программа должна правильно ввести исходные данные.
Комментировать  исходные  данные  в файле не надо, если это не
требуется по условию.
В  процессе  работы  программа  должна  обрабатывать те файлы,
которые  расположены в текущем директории (т.е. не обязательно
на диске А:).
Придерживайтесь  формы  ввода  данных  и  вывода  результатов,
приведенных в условиях задач и в примерах !
Пользуйтесь примерами для отладки программ. Но успешная работа
программы  на приведенных примерах не гарантирует правильности
программы !

3.  Для  обработки  каждого  теста  существуют  ограничения по
времени: как правило, 30 секунд.
4.  Если  могут  существовать  разные варианты решения задачи,
удовлетворяющие условию, достаточно представить одно из них.
5. Правильность исходных данных проверять не надо, если это не
оговорено особо условием задачи.
6.  Все  результирующие  материалы должны быть предоставлены в
согласованные  сроки  на  дискете формата 1.44M операционной 
системы MS DOS.
Файловая   структура   информации   на  дискете  должна  иметь
следующий вид.
Каждый участник предоставляет файлы 4-х разновидностей:
1. Текстовые ASCII-файлы решений задач.
2. Исполнимые .EXE-файлы решений задач.
3. Файлы исходных данных, необходимые для запуска исполнимых файлов.
4. Текстовый ASCII-файл с именем READ.ME, содержащий сведения об
участнике (ФИО, класс).

ПРИНЦИПЫ ОЦЕНИВАНИЯ ПРИСЛАННЫХ РАБОТ

Оценка  работ  производится по результатам прогонов исполнимых
(.EXE-)  файлов  программ-решений на тестовых наборах исходных
данных. Может быть проверен также текст программы-решения.
Все работы проверяются на одном и том же компьютере.
Для  достижения  независимости  оценки  от особенностей работы
операций  ввода/вывода  проверяемая  программа,  все  исходные
данные и результаты помещаются на виртуальный диск.
Процедура проверки работ состoит из последовательности этапов,
каждый  из  которых  приносит  проверяемой программе некоторое
количество баллов.
Далее приведено описание этапов проверки с указанием их стоимости в
процентах по отношению к стоимости всего решения задачи.

1. Проверка работоспособности    (до 50% баллов)
Проверка работоспособности заключается в том, чтобы при помощи
проверяемой  программы получить из файла, содержащего тестовые
наборы исходных данных, файл, содержащий правильные результаты
решения.    Каждый   тест   приносит   проверяемой   программе
определенное количество баллов.

2. Проверка оптимальности решения       (до 50% баллов)
Оптимальным    считается    решение,    выдержавшее   проверку
работоспособности   и   обладающее  наименьшей  вычислительной
сложностью.    Критерием    оптимальности    является   время,
затраченное программой на решение поставленной задачи.
Оценка  оптимальности  производится пропорционально количеству
затраченного    программой    времени   относительно   времени
выполнения эталонной программы.
В  качестве  показателя  оптимальности  проверяемой  программы
используется  величина  дроби  t/t0,  где  t  -  время  работы
проверяемой  программы , t0 - время работы эталонной программы
на  том  же  файле  исходных  данных.  Длительность выполнения
замеряется при помощи следующей программы (файл EXECTIME.PAS).

{$A-,B-,D-,E+,F-,G-,I+,L-,N+,O-,P-,Q+,R+,S+,T-,
        V+,X+,Y-}
{$M 4096,0,0}

uses Dos;
const
        tickvalue = 1/18;

        function Zero(w : Word) : String;
        var
                s : String;
        begin
                Str(w:0,s);
                if Length(s) = 1        then    s := '0' + s;
                Zero := s;
        end;
var
        ticktime: longint absolute $0040:$006c;
        t: longint;
        parstr: string;
        i: integer;
        h,m,s,s100: word;
        time: double;
begin
if ParamCount=0 then
begin
  writeln('ExecTime  V 1.0  1995   A.L.Khizha',#13#10,
        'Executes a specified program with a specified ',
        'command line and displays duration',#13#10,
        'Usage:',#13#10,
        '               ExecTime  program_name command_line'
        );
  exit;
end;

{ Склеить параметры }
for i:=2 to ParamCount do parstr:=parstr+ParamStr(i)+' ';

{ Засечь время и выполнить программу }
t:=ticktime;
exec(Paramstr(1),parstr);
t:=ticktime-t;

time:=t*tickvalue;
s100:= trunc( 100*frac(time));
h:= trunc(time)div 3600;
m:= (trunc(time)-h*3600)div 60;
s:= (trunc(time)-h*3600)mod 60;
writeln(output,
'Файл: ',ParamStr(1):12,'; время выполнения: ',
Zero(h):2,':',Zero(m):2,':',Zero(s):2,',',
                                Zero(s100):2,' (',t,')',#13#10,
'      ',         '':12,'; параметры: ',parstr);
end.
